
/*
 * Stripe integration allowing users to purchase a subscription type of product.
 */
.arguments
   price:string
   payment_method:string
   meta:string
.description:Creates a new subscription and associates with the currently authenticated user

// Sanity checking invocation.
auth.ticket.verify:root, admin, guest, impersonated

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/price
validators.mandatory:x:@.arguments/*/payment_method

// Retrieving username that we'll need to extract username from customers table.
auth.ticket.get

/*
 * Opening up a database connection to our stripe database, since we want to store
 * values associating the username with stripe internal data as we proceed.
 */
data.connect:[generic|stripe]

   // Will contain customer-id and payment method reference in Stripe's systems.
   .customer-id
   data.read
      table:customers
      values
         customer_id
      where
         and
            username.eq:x:@auth.ticket.get

   // Verifying we've previously created a customer, and/or payment method
   if
      not
         exists:x:@data.read/*/*
      .lambda

         // Customer has not previously been created.
         log.error:Tried to create subscription before creating a customer or payment method
            username:x:@auth.user.get
         throw:No payment method, and/or customer created
            public:true
            status:401

   // Setting customer id and payment method.
   set-value:x:@.customer-id
      get-value:x:@data.read/*/*/customer_id

   // Checking if request had a [meta] argument.
   if
      and
         exists:x:@.arguments/*/meta
         not
            eq:x:@.arguments/*/meta
               .
         not
            eq:x:@.arguments/*/meta
               .:
      .lambda
         add:x:@data.connect/*/signal
            get-nodes:x:@.arguments/*/meta

   /*
    * Now we have a customer, a payment method, and the customer and its payment method
    * are associated with each other internally in our database, and in Stripe's systems.
    *
    * Hence, now we can create our subscription.
    */
   unwrap:x:+/*
   signal:stripe.subscriptions.create
      customer_id:x:@.customer-id
      payment_method:x:@.arguments/*/payment_method
      price:x:@.arguments/*/price

   // Invoking any callback sink methods, but only if meta information was supplied.
   if
      exists:x:@.arguments/*/meta
      .lambda

         // Retrieving all slots that are interested in callback notifications.
         slots.vocabulary:payments.subscriptions.subscribed.
         
         // Invoking all slots returned above.
         for-each:x:-/*
            add:x:./*/signal
               get-nodes:x:@.arguments/*/meta
            unwrap:x:+/*
            signal:x:@.dp/#
               type:subscription
               username:x:@auth.ticket.get
               price:x:@.arguments/*/price
               completed:x:@signal/@signal/*/finished

   // Checking if we've got a notifications callback, and if so, invoking it.
   config.get:"magic:stripe:notifications"
   unwrap:x:+/*/username
   try-signal:x:@config.get
      type:subscription
      content:Your subscription was successfully created
      username:x:@auth.ticket.get

   // Creating our subscription and storing it in our database.
   data.create
      table:subscriptions
      values
         username:x:@auth.ticket.get
         subscription:x:@signal/*/id
         price:x:@.arguments/*/price
         product:x:@signal/*/product
         payment_method:x:@.arguments/*/payment_method
         meta:x:@.arguments/*/meta
         completed:x:@signal/*/finished

   /*
    * Checking if charge was successful.
    * Notice, subscriptions doesn't return an "authorisation URL"
    * for the payment from Stripe for some reasons, andthe invoice needs to
    * be retrieved, and the user needs to manually pay the invoice.
    * This is obviously annoying, but I suspect it's a 3D Secure "feature".
    *
    * For subscriptions, we still create the subscription in the database,
    * and invoke callback slots, etc - However, we return response to the client
    * indicating he or she needs to pay the invoice.
    */
   if
      not
         get-value:x:@signal/*/finished
      .lambda
         unwrap:x:+/*
         return
            finished:bool:false
            subscription:x:@signal/*/id
            message:Please check your email and pay the invoice

   // Returning success to caller.
   unwrap:x:+/*
   return
      finished:bool:true
      subscription:x:@signal/*/id
