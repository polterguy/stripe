
/*
 * Stripe integration allowing users to purchase a subscription type of product.
 */

.arguments
   card_number:string
   card_exp_month:string
   card_exp_year:string
   card_cvs:string
   price:string

// Sanity checking invocation.
auth.ticket.verify:root, admin, guest

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/card_number
validators.mandatory:x:@.arguments/*/card_exp_month
validators.mandatory:x:@.arguments/*/card_exp_year
validators.mandatory:x:@.arguments/*/card_cvs

// Retrieving username that we'll need to extract name and email.
auth.ticket.get

// Retrieving user's name and email address which we'll need to create our subscription.
.email
.name
data.connect:magic
   data.read
      table:users_extra
      values
         type
         name
      where
         and
            user.eq:x:@auth.ticket.get
            or
               type.eq:email
               type.eq:name
   set-value:x:@.email
      get-value:x:@data.read/*/*/type/=email/./*/value
   set-value:x:@.name
      get-value:x:@data.read/*/*/type/=name/./*/value

/*
 * Opening up a database connection to our stripe database, since we want to store
 * values associating the username with stripe internal data as we proceed.
 */
data.connect:stripe

   // Will contain customer-id and payment method reference in Stripe's systems.
   .customer-id
   .payment-method
   data.read
      table:customers
      values
         customer_id
         payment_method
      where
         and
            username.eq:x:@auth.ticket.get

   /*
    * Checking if we have previously create a customer object, and if so,
    * storing the previously create customer ID.
    */
   if
      and
         exists:x:@data.read/*/*
         not
            eq:x:@data.read/*/*/customer_id
               .
         not
            eq:x:@data.read/*/*/customer_id
               .:
      .lambda

         // Customer has previously been created.
         set-value:x:@.customer-id
            get-value:x:@data.read/*/*/customer_id

         // Checking if we already have a payment method associated with client.
         if
            and
               exists:x:@data.read/*/*/payment_method
               neq:x:@data.read/*/*/payment_method
                  .
               neq:x:@data.read/*/*/payment_method
                  .:
            .lambda
               set-value:x:@.payment-method
                  get-value:x:@data.read/*/*/payment_method

         else

            /*
             * No payment method associated with user, possibly because of erronously
             * supplying numbers from card, etc. Hence, creating a new payment method with
             * the specified data.
             */
            unwrap:x:+/*
            signal:strips.payment_method.create
               card_number:x:@.arguments/*/card_number
               card_exp_month:x:@.arguments/*/card_exp_month
               card_exp_year:x:@.arguments/*/card_exp_year
               card_cvs:x:@.arguments/*/card_cvs

            // Attaching payment method with customer in Stripe.
            unwrap:x:+/*
            signal:strips.payment_method.attach
               payment_method:x:@signal/@signal
               customer_id:x:@.customer-id

            // Updating our internal database records.
            data.update
               table:customers
               values
                  payment_method:x:@signal
               where
                  and
                     username.eq:x:@auth.ticket.get
            set-value:x:@.payment-method
               get-value:x:@signal

   else

      // We need to create a customer object.
      unwrap:x:+/*
      signal:stripe.customers.create
         username:x:@auth.ticket.get
         name:x:@.name
         email:x:@.email

      // Inserting our customer object
      data.create
         table:customers
         values
            username:x:@auth.ticket.get
            customer_id:x:@signal

      // Setting customer id.
      set-value:x:@.customer-id
         get-value:x:@signal

      // Creating a new payment method towards Stripe.
      unwrap:x:+/*
      signal:strips.payment_method.create
         card_number:x:@.arguments/*/card_number
         card_exp_month:x:@.arguments/*/card_exp_month
         card_exp_year:x:@.arguments/*/card_exp_year
         card_cvs:x:@.arguments/*/card_cvs

      // Attaching payment method with customer in Stripe.
      unwrap:x:+/*
      signal:strips.payment_method.attach
         payment_method:x:@signal/@signal
         customer_id:x:@.customer-id

      // Attaching payment method to customer in our internal database.
      data.update
         table:customers
         values
            payment_method:x:@signal/@signal
         where
            and
               username.eq:x:@auth.ticket.get
      set-value:x:@.payment-method
         get-value:x:@signal

   /*
    * Now we have a customer, a payment method, and the customer and its payment method
    * are associated with each other internally in our database, and in Stripe's systems.
    *
    * Hence, now we can create our subscription.
    */
   unwrap:x:+/*
   signal:stripe.subscriptions.create
      customer_id:x:@.customer-id
      price:x:@.arguments/*/price
      payment_method:x:@.payment-method

   // Returning success to caller.
   return
      result:success
